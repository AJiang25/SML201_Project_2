---
title: "Project 2 - Edson"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    embed-resources: true
    code-overflow: wrap
editor: visual
---

## Our Team

Fill the vector `our_team` with the full names (First Last) of each team member. Although this task is worth no points, failing to complete this task will result in a one-point deduction.

```{r our_team}
our_team = c('Arnold Jiang', 'John Woo', 'Tong Dai', 'Willow Yang')
our_team
```

## Our Country

Fill the string `our_country` with the country of the football team you wish to follow during the World Cup. Only one country must be selected. The name of this country must be spelled exactly as it appears in the `wc_sched` dataset (linked below). Hence you must select one of the countries from this dataset. Although this task is worth no points, failing to complete this task will result in a three-point deduction.

```{r our_country}
our_country = 'Argentina'
```

## Our Seed

Fill the value `our_seed` with a calculated seed to precede all random sampling actions throughout this project. This way, your code can be executed for verification and reproduction. Although this task is worth no points, failing to complete this task will result in a five-point deduction.

```{r our_seed}
# calculate the seed to be the sum of the PUIDs of each teammate and then the remainder after dividing by 1746.
# for example, if you have two teammates with PUIDs 888888888 & 999999999,
our_seed = sum(920327399, 920400588, 920251660, 920293028) %% 1746
```

------------------------------------------------------------------------

## Introduction

The [FIFA World Cup](https://en.wikipedia.org/wiki/FIFA_World_Cup) is a quadrennial football (soccer in the US) tournament that captures the world's attention like no other sporting event. At its conclusion, one country will stand as the sole victor. Argentina is the reigning champion, having won the title in 2022.

Arguably, there is no greater single competitor in the history of this event than **Edson Arantes do Nascimento**, better known by his nickname **Pel√©**. He led the Brazilian national team to three World Cup titles during his career.

For the 2026 World Cup, the matches will be held in three countries - USA, Canada, and Mexico. For the first time ever, 48 countries will qualify for this tournament. They will be segmented into 12 different groups of four countries each. Each country will play three matches against the three other countries in their group. Based on their performance in the group stage, they may qualify for one of 32 spots in the knockout stage. There, it will become a single-elimination tournament (one loss and it's over) until one country remains victorious.

In this project, we will focus on answering questions related to the World Cup and the sport of football. Computational models and automated processes will be created from data related to the following three topics:

A.  Travel Planning
B.  Goal Modeling
C.  Match Predicting

At the conclusion of each section, a written summary (5-10 sentences) of your work is required. The summaries should include:

-   commentary on the results of your output
-   potential enhancements to the models/processes
-   any answers to questions from prior tasks within the section

The project will be graded on a basis of 100 maximum points.

There is an optional fourth section that can earn you bonus points (up to 33) for modeling the knockout stage of the 2026 World Cup. You can earn more than 100 points on this project with the completion of this section.

------------------------------------------------------------------------

## The Necessary Packages

Run this entire code chunk BEFORE proceeding to ensure that all subsequent code are recognized and executable.

```{r packages}
#| message: false
library(tidyverse)
library(highcharter)
library(leaflet)
library(gt)
library(corrplot)
```

------------------------------------------------------------------------

## A. Travel Planning \[*33 pts total*\]

As the world descends to North America for the 2026 World Cup, it will be a challenge to coordinate the travel plans for the myriad visitors. This section will focus on creating automated processes to organize the traveling activity of potential visitors.

#### A0a. Data

In order to simplify the logistics of this section, several datasets will be utilized:

-   `wc_sched`: the schedule of the World Cup 2026 group stage matches (while the dates and locations of the matches are set in stone, the actual participants have been simulated so that we can all use the same starting data)
-   `wc_airports`: a selected list of the airports near the match venues
-   `wc_flights`: a full weekly cycle of flights to and from the selected airports
-   `wc_golf`: a sample of golf courses in North America

```{r a0a}
#| message: false
#| echo: false

wc_sched = read_csv(file = 'https://www.dropbox.com/scl/fi/ih115ahuot6v2supm8u1c/wc_sched.csv?rlkey=m2mbgxk3cmv3llhh8qvzthvpb&st=sg419l0c&raw=1')

wc_airports = read_csv(file = 'https://www.dropbox.com/scl/fi/t5jrehqfmk180cy7r1nc6/wc_airports.csv?rlkey=p73osbqvhd3235cigrs87z2t0&st=ubehx1zr&raw=1')

wc_flights = read_csv(file = 'https://www.dropbox.com/scl/fi/qlc76t7q00q5mn4b9uplw/wc_flights.csv?rlkey=mqozspldbkpr60w2pmu6p8jt6&st=3ly372dv&raw=1')

wc_golf = read_csv(file = 'https://www.dropbox.com/scl/fi/euxyrmwc0w00pfnoyg2gs/wc_golf.csv?rlkey=rktp24us7y0yqtvi94eprfci4&st=3g7huoa7&raw=1')
```

1\. Data Dictionary - `wc_sched`

-   match: the number representing the sequence in which the matches will be played
-   group: the group (A to L) to which the match participants belong
-   match_dt: the date on which the match is scheduled to be played
-   ctry_a: the first of the two participants on the match
-   ctry_b: the second of the two participants on the match
-   venue: the name of the venue where the match will be played
-   city: the city where the venue is located
-   lat: the latitude of a spot on the venue field
-   lng: the longitude of a spot on the venue field

2\. Data Dictionary - `wc_airports`

-   name: the full name of the airport
-   code: a unique 3-letter code of the airport
-   lat: the latitude of a spot on the airport
-   lng: the longitude of a spot on the airport

3\. Data Dictionary - `wc_flights`

-   dow: the day of week on which the flight departs
-   dep: the time (hhmm), in the time zone of the departing airport, at which the flight is scheduled to depart
-   arr: the time (hhmm), in the time zone of the arriving airport, at which the flight is scheduled to arrive
-   airline: a unique 2-letter code of the airline running the flight
-   orig: the airport code of the originating airport
-   dest: the airport code of the destination airport

4\. Data Dictionary - `wc_golf`

-   course: the name of the golf course
-   country: the country where the course is located
-   lat: the latitude of a spot on the golf course
-   lng: the longitude of a spot on the golf course

#### A0b. Distance Function

This function will calculate the spherical distance (in miles) between two sets of geo-coordinates using the [Haversine formula](https://en.wikipedia.org/wiki/Haversine_formula). Run this code chunk so that you can utilize it as needed for this project.

```{r a0b}
# the distance function to calculate the distance in miles between two sets of geo-coordinates (lat1, lng1) & (lat2, lng2)
dist_mi = function(lat1, lng1, lat2, lng2) {
  R = 3963 # radius of earth in miles
  r1 = lat1 * pi / 180
  r2 = lat2 * pi / 180
  d1 = (lat2 - lat1) * pi / 180
  d2 = (lng2 - lng1) * pi / 180
  a = sin(d1/2)^2 + cos(r1) * cos(r2) * sin(d2/2)^2
  return(2 * R * atan2(sqrt(a), sqrt(1-a)))
}
```

#### A1. Getting Around \[*14 pts*\]

As your team members are avid fans of the sport and the magnitude of this global event, you are asked to create a function `itinerary` that will take as input three parameters:

1.  `ctry`: a country name (text string) for the country you wish to follow during the group stage
2.  `pdt`: a two-element vector containing the preferred 8-hour segment (integer: 1 to 3) referring to which third of the day the traveler wishes to depart (1: 0 to 759, 2: 800 to 1559, 3: 1600 to 2359) for just the initial leg of each flight
3.  `conn`: a two-element vector containing the number of flight connections (integer: 0 to 2) for each flight (n.b. a non-stop flight has zero connections)

The function must return a travel itinerary (as a data frame) that will contain, for each leg of the flight trip, the following columns:

-   flt: the flight number (12 or 23; 12 goes from match 1 to match 2, 23 goes from match 2 to match 3)
-   leg: the leg of the flight (1 to 3)
-   dep: the departure airport code
-   arr: the arrival airport code
-   dod: the date of departure
-   tod: the time of departure
-   doa: the date of arrival
-   toa: the time of arrival
-   the distance between (use `dist_mi` function) the two airports

This function must be able to return qualifying flights for up to two connections between the cities of travel.

The flight details must be optimized for:

-   dates (at least one day before a match)
-   airports (nearest airport to the match venue)
-   time between legs of connecting flights (at least an hour)
-   total flight distance (minimize for connecting flight trips)

Assume that you are already at the location of the first group stage match of your country.

```{r a1a}
# returns nearest airport given lat and lng coords
findNearestAirport = function(given_lat, given_lng) {
  nearest_airport <- wc_airports |>
    mutate(dist = dist_mi(given_lat, given_lng, lat, lng)) |>
    arrange(dist) |>
    slice(1) |>
    select(code, lat, lng)
  return(nearest_airport)
}

getTimeRanges <- function(pdt) {
  if (pdt == 1) {
      return(c(0, 759))
    } else if (pdt == 2) {
      return(c(800, 1559))
    } else {
      return(c(1600, 2359))
    }
}

getAirportLatLng <- function(airport) {
  if (airport == "LGA") { 
    df <- data.frame(lat = 40.7766, lng = -73.8742)
    return(df) #LGA flights are not in dataset, but there are LGA flights
  }
  latLng <- wc_airports |>
    filter(code == airport) |> 
    select(lat, lng)
  return(latLng)
}


formatTime <- function(time) {
  time_str <- sprintf("%04d", time)
  res <- paste0(substr(time_str, 1, 2), ":", substr(time_str, 3, 4), ":00")
  return(res)
}

formatTime2 <- function(time) {
  time_str <- sprintf("%04d", time)
  res <- paste0(substr(time_str, 1, 2), ":", substr(time_str, 3, 4))
  return(res)
}

findDirectFlights = function(dep_airport, arr_airport, match_dow, prev_dt, match_dt, pdt) {
  # get time ranges based on pdt, lat and long of depature and arrival airports
  time_ranges <- getTimeRanges(pdt)
  depLatLng <- getAirportLatLng(dep_airport)
  arrLatLng <- getAirportLatLng(arr_airport)
  
  directFlightOptions <- wc_flights |>
    filter(orig == dep_airport) |>   # flights departing from dep_airport
    filter(dest == arr_airport) |>   # flights arriving at arr_airport
    filter(
      # make sure the flight options are within the preferred time range for departure
      (dep >= time_ranges[1] & dep <= time_ranges[2])
    ) |>
    # represent day of week of flights numerically
    mutate(dow = match(dow, c("SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"))) |>
    # get departure date for flight
    mutate(dep_date = 
             ifelse(dow < match_dow, as.Date(match_dt) - days(match_dow - dow),
                    as.Date(match_dt) - days(match_dow - dow + 7)),
           dep_date = as.Date(dep_date)
           )|>
    # if it's a red eye flight, arr date becomes the next day
    mutate(
      arr_date = ifelse(arr < dep, as.Date(dep_date) + days(1), as.Date(dep_date)),
      arr_date = as.Date(arr_date)
    ) |>
    # make sure that flight is departing only after we're there at location
    filter(dep_date > as.Date(prev_dt)) |>
    # make sure flight is arriving a day before match_dt
    filter(arr_date < as.Date(match_dt)) |>
    # get dist between airports
    mutate(dist = dist_mi(depLatLng$lat, depLatLng$lng, arrLatLng$lat, arrLatLng$lng)) |>
    # arrange by the total dist and then the latest arrival date
    arrange(dist, desc(arr_date)) 
  return(directFlightOptions)
}

findOneConnection = function(dep_airport, arr_airport, match_dow, prev_dt, match_dt, pdt) {
  # get time ranges based on pdt, lat and long of depature and arrival airports
  time_ranges <- getTimeRanges(pdt)
  depLatLng <- getAirportLatLng(dep_airport)
  arrLatLng <- getAirportLatLng(arr_airport)
  
   # --- find qualifying first legs ---
  qualifyingFirstLeg <- wc_flights |>
    rowwise() |>
    filter(orig == dep_airport) |>   # flights departing from dep_airport
    filter(dest != arr_airport) |>   # first leg of the flight should not arrive at arr_airport
    filter(
      # make sure the flight options are within the preferred time range for departure
      (dep >= time_ranges[1] & dep <= time_ranges[2])
    ) |>
    # represent day of week of flights numerically
    mutate(dow = match(dow, c("SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"))) |>
    # get dist between airports 
    mutate(dist = dist_mi(depLatLng$lat, depLatLng$lng, getAirportLatLng(dest)$lat, getAirportLatLng(dest)$lng)) |>
    # selected wanted columns
    select(dow, dep, arr, orig, dest, dist)
  
   # --- find possible second legs ---
  possibleSecondLeg <- wc_flights |>
    rowwise() |>
    filter(orig %in% qualifyingFirstLeg$dest) |>   # orig needs to be a dest of the first leg
    filter(dest == arr_airport) |>                 # flight goes to final dest (arr_airport)
    # get dist between airports 
    mutate(dist = dist_mi(getAirportLatLng(orig)$lat, getAirportLatLng(orig)$lng, arrLatLng$lat, arrLatLng$lng)) |>
    # represent day of week of flights numerically
    mutate(dow = match(dow, c("SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"))) 
  
   # --- find qualifying flights with one connection ---
  qualifyingConnections <- qualifyingFirstLeg |>
    # merge the first and second legs to form one connection
    left_join(possibleSecondLeg, by = c('dest' = 'orig'), relationship = "many-to-many") |>
    # get departure and arrival dates
    mutate(
      final_dep_date = ifelse(dow.y < match_dow, 
                              as.Date(match_dt) - days(match_dow - dow.y),
                              as.Date(match_dt) - days(match_dow - dow.y + 7)),
      final_dep_date = as.Date(final_dep_date),
      final_arr_date = ifelse(arr.y > dep.y, 
                                     final_dep_date, final_dep_date + days(1)),
      final_arr_date = as.Date(final_arr_date),
      first_dep_date = ifelse(dow.x == dow.y, as.Date(final_dep_date), 
                              ifelse(dow.y > dow.x, 
                                     as.Date(final_dep_date) - days(dow.y - dow.x),
                                     as.Date(final_dep_date) - days(dow.y - dow.x + 7))),
      first_dep_date = as.Date(first_dep_date),
      first_arr_date = ifelse(arr.x > dep.x, first_dep_date, first_dep_date + days(1)),
      first_arr_date = as.Date(first_arr_date)
    ) |>
    # make sure that flight is departing only after we're there at location
    filter(first_dep_date > as.Date(prev_dt)) |>
    # make sure that flight is arriving a day before match_dt
    filter(final_arr_date < as.Date(match_dt)) |>
    # calculate layover duration of flights
    mutate(layover_duration = ifelse(final_arr_date == first_dep_date, 
                                            hm(dep.y) - hm(arr.x),
                                     difftime(as.POSIXct(paste(final_arr_date, 
                                                         formatTime(dep.y)), tz="UTC"), 
                                              as.POSIXct(paste(first_dep_date,
                                                         formatTime(arr.x)), tz="UTC"), 
                                              units = "mins"))) |>
    # make sure that we have at least an hour in between layover
    filter(layover_duration >= 60) |>
    mutate(total_dist = dist.x + dist.y) |>
    select(
      first_dow = dow.x,
      first_dep = dep.x,
      first_arr = arr.x,
      first_orig = orig,
      first_dest = dest,
      second_dow = dow.y,
      second_dep = dep.y,
      second_arr = arr.y,
      second_dest = dest.y,
      first_dep_date,
      first_arr_date,
      final_dep_date,
      final_arr_date,
      first_dist = dist.x,
      second_dist = dist.y,
      total_dist,
      layover_duration
    ) |>
    # arrange by the shortest layover duration 
    arrange(layover_duration) |>
    # remove dupes that fly to the same airports and choose only the one w shortest layover
    group_by(first_orig, first_dest, second_dest) |>
    slice(1) |>
    ungroup() |>
    # arrange by total dist and the latest final arrival date
    arrange(total_dist, desc(final_arr_date)) 
  return(qualifyingConnections)
}

findTwoConnection = function(dep_airport, arr_airport, match_dow, prev_dt, match_dt, pdt) {
  # get time ranges based on pdt, lat and long of depature and arrival airports
  time_ranges <- getTimeRanges(pdt)
  depLatLng <- getAirportLatLng(dep_airport)
  arrLatLng <- getAirportLatLng(arr_airport)
  
  # --- find qualifying first leg ---
  qualifyingFirstLeg <- wc_flights |>
    filter(orig == dep_airport, # flights departing from dep_airport
           dest != arr_airport, # first leg of the flight should not arrive at arr_airport
           # make sure the flight options are within the preferred time range for departure
           (dep >= time_ranges[1] & dep <= time_ranges[2])
           )   
  
  # --- find qualifying second leg ---
  possibleSecondLeg <- wc_flights |>
    filter(orig %in% qualifyingFirstLeg$dest,
           dest != arr_airport & dest != dep_airport) 
  
  # --- find qualifying third leg ---
  possibleThirdLeg <- wc_flights |>
    filter(orig %in% possibleSecondLeg$dest,
           dest == arr_airport) 
  
  # --- find qualifying last connection ---
  possibleLastConn <- possibleSecondLeg |>
    # merge second leg and third leg together
    left_join(possibleThirdLeg, by = c('dest' = 'orig'), relationship = "many-to-many") |>
    # get the depature and arrival dates for the flights
    mutate(dow.x = match(dow.x, c("SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT")),
           dow.y = match(dow.y, c("SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT")),
           final_dep_date = ifelse(dow.y < match_dow, 
                                   as.Date(match_dt) - days(match_dow - dow.y),
                            as.Date(match_dt) - days(match_dow - dow.y + 7)),
           final_dep_date = as.Date(final_dep_date),
           final_arr_date = ifelse(arr.y > dep.y, 
                                     final_dep_date, final_dep_date + days(1)),
           final_arr_date = as.Date(final_arr_date),
           
           second_dep_date = ifelse(dow.x == dow.y, as.Date(final_dep_date), 
                                      ifelse(dow.y > dow.x, 
                                             as.Date(final_dep_date) - days(dow.y - dow.x),
                                      as.Date(final_dep_date) - days(dow.y - dow.x + 7))),
           second_dep_date = as.Date(second_dep_date),
           second_arr_date = ifelse(arr.x > dep.x, second_dep_date, second_dep_date + days(1)),
           second_arr_date = as.Date(second_arr_date)
           ) |>
    # make sure that final arrival date arrives before match dt
    filter(final_arr_date < as.Date(match_dt)) |>
    # get second layover duration date
    mutate(second_layover_duration = ifelse(final_arr_date == second_dep_date, 
                                            hm(dep.y) - hm(arr.x),
                                     difftime(as.POSIXct(paste(final_arr_date, 
                                                         formatTime(dep.y)), tz="UTC"), 
                                              as.POSIXct(paste(second_dep_date,
                                                         formatTime(arr.x)), tz="UTC"), 
                                              units = "mins"))) |>
    # make sure the second layover duration is at least an hr
    filter(second_layover_duration >= 60) 
  
  qualifyingConns <- qualifyingFirstLeg |>
    # merge possible first leg and last connections
    inner_join(possibleLastConn, by = c("dest" = "orig"), relationship = "many-to-many") |>
    select(first_dow = dow,
           first_dep = dep,
           first_arr = arr,
           first_orig = orig,
           first_dest = dest,
           second_dow = dow.x,
           second_dep = dep.x,
           second_arr = arr.x,
           second_dest = dest.y,
           third_dow = dow.y,
           third_dep = dep.y,
           third_arr = arr.y,
           third_dest = dest.y.y,
           second_dep_date,
           second_arr_date,
           final_dep_date,
           final_arr_date,
           second_layover_duration
           ) |>
    # get departure and arrival dates for the first leg
    mutate(first_dow = match(first_dow, c("SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT")),
           first_dep_date = ifelse(first_dow == second_dow, as.Date(second_dep_date),
                             ifelse(second_dow > first_dow,
                                    as.Date(second_dep_date) - days(second_dow - first_dow),
                                    as.Date(second_dep_date) - days(second_dow - first_dow + 7))),
           first_dep_date = as.Date(first_dep_date),
           first_arr_date = ifelse(first_arr > first_dep, first_dep_date, 
                                   first_dep_date + days(1)),
           first_arr_date = as.Date(first_arr_date)
           ) |>
    mutate(first_layover_duration = ifelse(first_arr_date == second_dep_date,
                                           hm(second_dep) - hm(first_arr),
                                     difftime(as.POSIXct(paste(second_dep_date,
                                                         formatTime(second_dep)), tz="UTC"),
                                              as.POSIXct(paste(first_arr_date,
                                                         formatTime(first_arr)), tz="UTC"),
                                              units = "mins")),
           total_layover_duration = second_layover_duration + first_layover_duration) |>
    # make sure that first layover is at least an hr
    filter(first_layover_duration >= 60) |>
    # make sure that flight is departing only after we're there at location
    filter(first_dep_date > as.Date(prev_dt)) |>
    # arrange by shortest total layover duration
    arrange(total_layover_duration) |>
    # remove dupes that fly to same airport (only the one with shortest total layover stays)
    group_by(first_orig, first_dest, second_dest, third_dest) |>
    slice(1) |>
    ungroup() |>
    # arrange by the latest final arrival date
    arrange(desc(final_arr_date)) 

  qualifyingConns <- qualifyingConns |>
    rowwise() |>
    # get distances between airports
    mutate(first_dist = dist_mi(getAirportLatLng(first_orig)$lat,
                                getAirportLatLng(first_orig)$lng,
                                getAirportLatLng(first_dest)$lat,
                                getAirportLatLng(first_dest)$lng),
           second_dist = dist_mi(getAirportLatLng(first_dest)$lat,
                                getAirportLatLng(first_dest)$lng,
                                getAirportLatLng(second_dest)$lat,
                                getAirportLatLng(second_dest)$lng),
           third_dist =  dist_mi(getAirportLatLng(second_dest)$lat,
                                getAirportLatLng(second_dest)$lng,
                                getAirportLatLng(third_dest)$lat,
                                getAirportLatLng(third_dest)$lng),
           total_dist = first_dist + second_dist + third_dist
             ) |>
    # arrange by shortest total dist, the latest final arrival date, shortest layover duration
    arrange(total_dist, desc(final_arr_date), total_layover_duration)
  return(qualifyingConns)
}

itinerary = function(ctry, pdt, conn) {
    # filter based on country wished to follow & get the venues/cities/lat/lng that they will
    # be playing in (arranged by dates)
    countryInfo <- wc_sched |>
        filter(ctry_a == ctry | ctry_b == ctry) |>
        arrange(match_dt) |>
        select(match_dt, venue, city, lat, lng)

    # find the nearest airport for each venue
    countryInfo <- countryInfo |>
      rowwise() |>
      mutate(
        nearestAirport = findNearestAirport(lat, lng)$code,
        wkday = wday(match_dt, label = FALSE)) 
    
    # initialize empty itinerary dataframe
    itin <- data.frame()
    
    for (i in 1:(nrow(countryInfo) - 1)) {
        dep_airport <- countryInfo$nearestAirport[i]
        arr_airport <- countryInfo$nearestAirport[i + 1]
        match_dow <- countryInfo$wkday[i + 1]
        match_dt <- countryInfo$match_dt[i + 1]
        prev_dt <- countryInfo$match_dt[i]
        
        flt_number <- ifelse(i == 1, 12, 23)
        if (conn[i] == 0) {
            flight <- findDirectFlights(dep_airport, 
                                        arr_airport, match_dow, prev_dt, match_dt, pdt[i]) [1,]
            itin <- rbind(itin, data.frame(
                flt = flt_number, leg = 1, 
                dep = flight$orig, arr = flight$dest, 
                dod = flight$dep_date, tod = formatTime2(flight$dep),
                doa = flight$arr_date, toa = formatTime2(flight$arr),
                dist = round(flight$dist)))
        } else if (conn[i] == 1) {
            flight <- findOneConnection(dep_airport, 
                                        arr_airport, match_dow, prev_dt, match_dt, pdt[i])[1,]
            itin <- rbind(itin, data.frame(
                flt = flt_number, leg = 1, 
                dep = flight$first_orig, arr = flight$first_dest, 
                dod = flight$first_dep_date, tod = formatTime2(flight$first_dep),
                doa = flight$first_arr_date, toa = formatTime2(flight$first_arr),
                dist = round(flight$first_dist)))
            itin <- rbind(itin, data.frame(
              flt = flt_number, leg = 2,
              dep = flight$first_dest, arr = flight$second_dest,
              dod = flight$final_dep_date, tod = formatTime2(flight$second_dep),
              doa = flight$final_arr_date, toa = formatTime2(flight$second_arr),
              dist = round(flight$second_dist)
            ))
        } else {
            flight <- findTwoConnection(dep_airport, 
                                        arr_airport, match_dow, prev_dt, match_dt, pdt[i])[1,]
            itin <- rbind(itin, data.frame(
                flt = flt_number, leg = 1, 
                dep = flight$first_orig, arr = flight$first_dest, 
                dod = flight$first_dep_date, tod = formatTime2(flight$first_dep),
                doa = flight$first_arr_date, toa = formatTime2(flight$first_arr),
                dist = round(flight$first_dist)))
            itin <- rbind(itin, data.frame(
              flt = flt_number, leg = 2,
              dep = flight$first_dest, arr = flight$second_dest,
              dod = flight$second_dep_date, tod = formatTime2(flight$second_dep),
              doa = flight$second_arr_date, toa = formatTime2(flight$second_arr),
              dist = round(flight$second_dist)
            ))
            itin <- rbind(itin, data.frame(
              flt = flt_number, leg = 3,
              dep = flight$second_dest, arr = flight$third_dest,
              dod = flight$final_dep_date, tod = formatTime2(flight$third_dep),
              doa = flight$final_arr_date, toa = formatTime2(flight$third_arr),
              dist = round(flight$third_dist)
            ))
        }
    }
    return(itin)
}

```

Create an actual itinerary using the function with the following conditions:

-   `ctry` = `our_country`
-   One flight must be a non-stop one.
-   The other flight must have two connections.
-   `pdt` must contain two different values as its elements.

Display your itinerary using `gt`. Stylize the table to look neat and organized.

```{r a1b}
country_info <- wc_sched |>
        filter(ctry_a == our_country | ctry_b == our_country) |>
        arrange(match_dt) |>
        select(match_dt, ctry_a, ctry_b, venue, city, lat, lng)

match_data <- country_info |>
  mutate(text = 
           paste0("Match ", row_number(), " (", match_dt, "): ", 
                 ctry_a, " v ", ctry_b, " @ ", venue, "<br>")) |>
  pull(text) 

our_itinerary = itinerary(ctry = our_country, pdt = c(1, 3), conn = c(0, 2))
our_itinerary |> 
  gt() |>
  tab_header(
    title = "Flight Itinerary",
    subtitle = "Group Stage - Argentina"
  ) |>
  cols_label(
    flt = "flt",
    leg = "leg",
    dep = "dep",
    arr = "arr",
    dod = "dod",
    tod = "tod",
    doa = "doa",
    toa = "toa",
    dist = "dist"
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "navy"),  
      cell_text(color = "white")  
    ),
    locations = cells_title()
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "steelblue"),  
      cell_text(color = "white")  
    ),
    locations = cells_column_labels()
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "lightyellow"),  
      cell_text(color = "black")  
    ),
    locations = cells_body(
      rows = (flt == 12)
    )
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "lightgreen"),  
      cell_text(color = "black")  
    ),
    locations = cells_body(
      rows = (flt == 23)
    )
  ) |>
  tab_footnote(
    footnote = md(match_data)
  )
```

#### A2. A Side Trip \[*6 pts*\]

Since there will be much down time in between the group stage matches of your country, you and your team decide to play a round of golf at a course near one of your country's match venues.

Perform your own research and analysis to determine which golf course (from `wc_golf`) to play your round of golf. All the courses are well-known courses for which much online content exists.

You can play the round on any course from `wc_golf`, but it must be chosen based on some logical reasoning (i.e. no random selection).

You cannot fly to your golf course.

You must then schedule a day between your country's matches to play your round of golf.

Create a list, called `golf_round`, that contains the following elements:

-   course: the name of the golf course
-   tee_time: the date and time of your scheduled round
-   dist: the distance between the course and the match venue
-   reason: your reason for playing on this course
-   architect: the name(s) of the course architect
-   fun_fact: a fun fact about the course based on your research

```{r a2}

# find golf courses within 50 miles of venue coord, arranged based on closest to furthest dist 
findGolfCourses <- function(venueLat, venueLng) {
  golf_courses <- wc_golf |>
    mutate(dist = dist_mi(venueLat, venueLng, lat, lng)) |>
    filter(dist <= 50) |>
    arrange(dist) |>
    select(course, dist)
  
  return(golf_courses)
}

# store a list of nearby golf courses based on venues
golfCourseByVenue <- country_info |>
  rowwise() |>
  mutate(golf_courses = list(findGolfCourses(lat, lng)$course),
         golf_courses_dist = list(findGolfCourses(lat, lng)$dist)
         )

# want to play in boston since we arrive on 06/21 when match is on 06/23 for match 2
match_num = 2
bostonGolfCourseList <- golfCourseByVenue$golf_courses[[match_num]]
bostonGolfCourseDistList <- golfCourseByVenue$golf_courses_dist[[match_num]]


# pick the first one since we want the closest one
selectedGolfCourse <- bostonGolfCourseList[1]
selectedGolfCourseDist <- round(bostonGolfCourseDistList[1])

golf_round <- list(
  course = selectedGolfCourse,
  tee_time = as.POSIXct("2026-06-22 12:00:00"),
  dist = paste(selectedGolfCourseDist, "miles"),
  reason = "Since we are arriving two days prior to Argentina's match against Tunisia in Boston, we might as well play a round of golf near the Gillette Stadium.",
  architect = "Willie Campbell, Alex Campbell, William S. Flynn",
  fun_fact = "It was the very first country club in the U.S., dating to 1882."
)

golf_round
```

#### A3. The Travel Map \[*10 pts*\]

Using `leaflet`, map the locations of the venues at which your country will be playing its group stage matches.

Create markers (`addAwesomeMarkers`) such that they are labeled 1, 2, or 3 in the chronological order of matches to be played.

Place a single marker, using the image `golf_marker`, at the course where you decide to play your round of golf.

In the popup for each marker, include pertinent information about the match or the course. Note that when you render this document, the popups should not appear. But your code must include this feature such that if run on another machine, they will show.

Use an appropriate set of provider tiles to allow the markers to clearly stand out.

```{r a3}

golf_marker = 'https://www.dropbox.com/scl/fi/rdsbwddqv46ebrjt5tecj/golf_marker.png?rlkey=nko2qqggh6blvzfs7m0463xlf&st=mbzlrj0c&raw=1'

country_info <- country_info |>
  mutate(match_num = row_number(),
         popup = paste0(
           "Venue: ", venue, "<br>",
           "Match Date: ", match_dt, "<br>",
           "Located in: ", city, "<br>",
           "Latitude: ", lat, "<br>",
           "Longitude: ", lng, "<br>",
           "Country ", ctry_a, " is playing against ", ctry_b, ".<br>"
         ))

golf_icon <- makeIcon(
  iconUrl = golf_marker,
  iconWidth = 30,   
  iconHeight = 30
)

getGolfInfo <- wc_golf |>
  filter(course == selectedGolfCourse)


golf_popup <- paste0(
  "Course: ", getGolfInfo$course, "<br>",
  "Country: ", getGolfInfo$country, "<br>",
  "Latitude: ", getGolfInfo$lat, "<br>",
  "Longitude: ", getGolfInfo$lng, "<br>",
  "Architects: ", golf_round$architect, "<br>",
  "Distance from Gillette Stadium: ", golf_round$dist, "<br>",
  "Fun Fact: ", golf_round$fun_fact, "<br>"
)

# match 1
leaflet() |>
  addProviderTiles(providers$CartoDB.Positron) |> 
  addAwesomeMarkers(data = country_info[1,], ~lng, ~lat,
                    label = ~match_num,
                    popup = ~popup) |>
  setView(lng = country_info$lng[1], lat = country_info$lat[1], zoom = 7)

# match 2 with golf icon
leaflet() |>
  addProviderTiles(providers$CartoDB.Positron) |> 
  addAwesomeMarkers(data = country_info[2,], ~lng, ~lat,
                    label = ~match_num,
                    popup = ~popup) |>
  addMarkers(data = getGolfInfo, ~lng, ~lat, 
             icon = golf_icon,
             label = "Golf Course (The Country Club)",
             popup = golf_popup) |>
  setView(lng = country_info$lng[2], lat = country_info$lat[2], zoom = 7)

# match 3
leaflet() |>
  addProviderTiles(providers$CartoDB.Positron) |> 
  addAwesomeMarkers(data = country_info[3,], ~lng, ~lat,
                    label = ~match_num,
                    popup = ~popup) |>
  setView(lng = country_info$lng[3], lat = country_info$lat[3], zoom = 7)

# leaflet containing all matches with golf venue
leaflet() |>
  addProviderTiles(providers$CartoDB.Positron) |> 
  addAwesomeMarkers(data = country_info, ~lng, ~lat,
                    label = ~match_num,
                    popup = ~popup) |>
  addMarkers(data = getGolfInfo, ~lng, ~lat, 
             icon = golf_icon,
             label = "Golf Course (The Country Club)",
             popup = golf_popup) |>
  setView(
    lng = mean(c(country_info$lng, getGolfInfo$lng)),
    lat = mean(c(country_info$lat, getGolfInfo$lat)),
    zoom = 6)
```

#### A4. Summary \[*3 pts*\]

Write a concluding paragraph on your observations during the completion of this section. Contain all your words within the blockquote below by replacing the word 'Summary' with your text.

> For part a1, we prioritized selecting flights based on the shortest travel distance, and from these flights, we then focused on choosing those with the latest arrival dates and the shortest layovers. We prioritized the latest arrival times because our main goal was to arrive at the match locations a day before the event. We weren't focused on allowing extra downtime in each destination, so we opted for the flights that would get us there as close to the match date as possible. For flights with connections, we made sure to remove duplicate entries for flights that passed through the same airports, keeping only the one with the shortest layover. We found that without removing duplicates, the number of possible permutations and combinations would grow significantly, which slowed down the algorithm's runtime. By eliminating duplicates, we were trying to optimize the process and improve runtime efficiency. For part a2, we knew we had downtime after we arrived in the area for match 2, so we decided to play a round of golf near the stadium of match 2. We chose our golf course based on the one nearest to the match stadium, since we didn't want to travel too far. For part a3, we created four leaflets: the first three displayed a single venue that corresponded to the matches, with the second one including the golf course we're playing at, and the fourth one included all the venues together along with the golf course.

------------------------------------------------------------------------

## B. Goal Modeling \[*33 pts total*\]

In the sport of soccer, one objective of the player with the ball is to score a goal. Based on the conditions surrounding each shot, the probability of scoring a goal has been computed using machine learning techniques. This statistic is called xG (expected goal) and ranges in value from 0 to 1. In this section, we would like to study the various factors influencing the value of xG via linear models.

#### B0. Data

The `wc_shots` dataset contains details for every shot taken by a player during the World Cup 2022 in Qatar.

```{r b0}
#| message: false
#| echo: false

wc_shots = read_csv(file = 'https://www.dropbox.com/scl/fi/z3w948hf8yswtme1bkvyq/wc_shots.csv?rlkey=nn7dixivvxmtez93eusmse0cx&st=71rnvvuf&raw=1')
```

Data Dictionary

-   shot_type: the result of the shot taken
-   situation: the match situation during which the shot was taken
-   body_part: the part of the body used to take the shot
-   shot_time: the time (in seconds) of the game when the shot was taken
-   player: the name of the shooter
-   pos: the position of the shooter
-   x: the x-coordinate where the shot was taken (see image in B1)
-   y: the y-coordinate where the shot was taken (see image in B1)
-   xg: the expected goal probability of the shot

#### B1. Data Prep \[*8 pts*\]

Before the models can be built, you will need to prepare some of the data to allow for easier inclusion into the models.

-   Remove penalty kicks from your training data.
-   Create dummy variables `pos_d`, `pos_f`, and `pos_m` such that they equal:
    -   1 if the player `pos` = D, F, or M respectively
    -   0 if not
-   Mutate new columns (`d` & `theta`) into `wc_shots`. `d` is the Euclidean distance (in yards) from the origin. `theta` is the angle measure (in degrees) from the y-axis. It does not matter to which side the ball is to the y-axis, `theta` will be measured as a positive value. You'll need to use some trigonometry to compute `theta`. See this image for reference.

![](https://www.dropbox.com/scl/fi/1xqlflad3sjt6e9e5onw0/pitch_grid.png?rlkey=sks3ffdb9e4aoov962e7brsb3&st=gtvoed7f&raw=1){fig-align="center" width="85%"}

```{r b1}
#remove penalty & add dummy variables
wc_shots = wc_shots %>% 
    filter(situation != 'penalty') %>%
    mutate(
        pos_d = ifelse(pos == 'D', 1, 0), 
        pos_f = ifelse(pos == 'F', 1, 0),
        pos_m = ifelse(pos == 'M', 1, 0)
    )

# d & theta
wc_shots = wc_shots %>% 
    mutate(
        d = sqrt(x^2 + y^2),
        theta = abs(atan2(x, y)) * (180/pi)
    )

wc_shots

```

#### B2. Simple Models \[*10 pts*\]

Create a linear regression model (`model1`) of expected goal as a function of the shot distance (`d`) from the origin and the angle (`theta`) from the y-axis.

Generate R^2^ for this model. Explain the meaning of this R^2^ value in the summary section.

Generate the `corrplot` for all pairs of variables in this model. Explain the takeaways from this plot in the summary section.

```{r b2}
# linear regression model
model1 = lm(xg ~ d + theta, wc_shots)
model1

# R^2 value
R2 = summary(model1)$r.squared
R2

# 9 numerical vars - need to add shot_time but it's not in the data table for some reason...
wc_shots
wc_corr = wc_shots %>% 
    select(pos_d, pos_f, pos_m, xg, x, y, d, theta, shot_time) %>%
    cor()
corrplot(wc_corr, method = 'circle', type = 'upper')

```

#### B3. Complex Models \[*12 pts*\]

Create a linear regression model (`model2`) of expected goal as an exponential function of `d` and `theta`. That is `xg` \~ exp(`d` + `theta`).

Is `model1` or `model2` better for predicting `xg`? Provide your reasons in the summary section.

```{r b3a}
# log(xg) to make it linear, xg can't be 0
wc_shots_clean = wc_shots %>% 
  filter(xg != 0) %>% 
  mutate(transform_xg = log(xg))

# linear regression model
model2 = lm(transform_xg ~ d + theta, wc_shots_clean)
model2

# R^2 value - greater than 0.5
R2 = summary(model2)$r.squared
R2

```

Generate a scatter plot of `xg` vs `d`. Overlay that with the regression line of `model2`. Comment on what the chart reveals in the summary section.

You can use either `highcharter` or `ggplot2`.

```{r b3b}
#regression data (turn it back to nonlinear)
wc_sample = wc_shots |> 
  slice_sample(n = 200) |> 
  arrange(d) |> 
  mutate(regression_data= round(
    exp(model2$coefficients[1] + 
        model2$coefficients[2] * d), 5))

hchart(
  object = wc_shots,
  mapping = hcaes(x = d, y = xg),
  type = 'scatter'
) %>%
  hc_plotOptions(scatter = list(marker = list(radius = 2))) %>% 
  hc_title(text = "xg vs d Scatter Plot") %>% 
  hc_xAxis(title = list(text = "Euclidean distance (d)")) %>% 
  hc_yAxis(title = list(text = "Expected Goal Probability (xg)")) %>% 
  hc_add_series(
    wc_sample,
    hcaes(
        x = d,
        y = regression_data),
        type = 'line'
    )

```

#### B4. Summary \[*3 pts*\]

Write a concluding paragraph on your observations during the completion of this section. Contain all your words within the blockquote below by replacing the word 'Summary' with your text.

> The first model was a linear regression model that used distance and angle as predictors. We obtained an R\^2 value of 0.3171156, which means that (\~31.7%) of the variability of the expected goals is explained by the model (between the distance and angle predictors). This means that model1 likely was not as effective in predicting the expected goals (xg). The corrplot graph shows a high negative correlation between pos_m (midfield) and pos_f (forward), a somewhat negative correlation between xg and d (distance), and a high positive correlation between d and y. The rest of the variables seemed to have a low negative/positive correlation betwen each other. The results make sense as a midfielder tends to not be a forward player and as distance increases, the expected goal decreases. The correlation bewteen xg and d is stronger than with theta because distance directly impacts the probability of making a goal whereas the angle relative to the goal has less of an impact.It's also likely that there is a high correlation between d and y and not with the x-coordinate because the goal is centered at (0,0) and the y-coordinate represents the vertical distance from the goal which would have a higher impact than the x-coordinate (horizontal distance). The exponential model 2 demonstrated that it was a better predictor of xg because it had an R\^2 value of 0.5677117, which means that (\~56.8%) of the variability of the expected goals is explained by the model (between the distance and angle predictors). Therefore, the results indicate that there is a non-linear relationship between the distance/angle predictors and the expected goals. The results that we obtained earlier are confirmed in the scatter plot as we see an exponential decay in the expected goal probability as distance increases. This makes sense as shots taken closer to the goal have exponentially better chances for scores.

------------------------------------------------------------------------

## C. Match Predicting \[*34 pts total*\]

Curious minds will want to know which country will win the World Cup. In order to get there, a country must play three group stage matches - one match against each country - to advance to the knockout stage.

#### C0. Data

The `wc_countries` dataset contains the entire 48-country field of participants in our version of the World Cup 2026 tournament. Several offensive and defensive statistics for each country have been derived to help with the game modeling.

```{r c0}
#| message: false
#| echo: false

wc_countries = read_csv(file = 'https://www.dropbox.com/scl/fi/3epqe5yjbbfrcg8ixcum8/wc_countries.csv?rlkey=ttdjyc667qpnlaqv7ffzw98a8&st=2ud9n04k&raw=1')
```

Data Dictionary

-   country: the countries participating in the World Cup
-   group: the group (A to L) to which the country belongs
-   osp: the shot per possession rate when the country is on offense
-   ogs: the goal per shot rate when the country is on offense
-   dsp: the shot per possession rate when the country is on defense
-   dgs: the goal per shot rate when the country is on defense

#### C1. Game Model \[*15 pts*\]

Create a function called `game_model` which has as input the two countries (a & b) that will be playing. The output will be a vector of the goals scored by each of the competing countries.

The model will need to simulate a football match using these rules:

-   Each country will take turns possessing the ball. `ctry_a` will have the possession at the start of the match. `ctry_b` will have the possession at the start of the second half.
-   Each possession will occupy an amount of time (in seconds) which will be sampled from a normal distribution with a mean of 45 and a standard deviation of 13. A possession duration must have a floor of 5 seconds.
-   Each possession will have an offensive or defensive bias which will be determined by a coin flip.
    -   When it is an offensive bias, the `osp` and `ogs` rates for the country with possession will determine if a goal is scored during the possession.
    -   When it is a defensive bias, the `dsp` and `dgs` rates for the country without possession will determine if a goal is scored during the possession.
-   Each possession will produce a binary outcome - score a goal or do not score a goal.
    -   A goal is scored when two random values between 0 to 1 are compared against the `osp` and `ogs` (or `dsp` and `dgs` as explained above) respectively.
    -   `osp` determines if a shot is taken during the possession.
    -   `ogs` determines if a goal is scored for that shot taken.
-   When the combined time of the possessions exceeds 45 minutes, the first half will end. When the combined time of another set of possessions exceeds 45 minutes, the match will end. There is no such thing as added time in this model.
-   The final goals scored by each country will dictate who won the match. In the group stage, matches can end in draws.

```{r c1}
game_model = function(a, b) {
    stats_a = wc_countries %>%
        filter(country == a)
    stats_b = wc_countries %>%
        filter(country == b)
    
    total_time = 0
    goals_a = 0
    goals_b = 0
    possession = "a"

    while (total_time < 90 * 60) { # 90 minutes
        # bare min time of 5 seconds
        possession_time = max(5, round(rnorm(1, mean = 45, sd = 13))) 

        # Check if the first half ends
        if (total_time < 45 * 60 && total_time + possession_time > 45 * 60) {
            possession = "b" 
            total_time = 45 * 60
            next
        }

        total_time = total_time + possession_time 
        bias = sample(c("offensive", "defensive"), 1)

        # Scoring Mechanics
        if (possession == "a") {
            if (bias == "offensive") { # Offensive bias for ctry_a
                if (runif(1) < stats_a$osp && runif(1) < stats_a$ogs) {
                    goals_a = goals_a + 1
                }
            } else { # Defensive bias for ctry_b
                if (runif(1) < stats_b$dsp && runif(1) < stats_b$dgs) {
                    goals_b = goals_b + 1
                }
            }
            possession = "b"
        } else {
            if (bias == "offensive") { # Offensive bias for ctry_b
                if (runif(1) < stats_b$osp && runif(1) < stats_b$ogs) {
                    goals_b = goals_b + 1
                }
            } else { # Defensive bias for ctry_a
                if (runif(1) < stats_a$dsp && runif(1) < stats_a$dgs) {
                    goals_a = goals_a + 1
                }
            }
            possession = "a"
        }
    }
    return(c(goals_a, goals_b))
}

```

#### C2. Group Stage Outcomes \[*10 pts*\]

With the `game_model` function, play all 72 of the group stage matches as listed in `wc_sched`.

Store all the results of the group stage matches in a data frame called `wc_grpstage`. This table must contain the following columns:

-   match: the number representing the sequence in which the matches were played
-   group: the group (A to L) to which the match participants belong
-   ctry_a: the first of the two participants on the match
-   ctry_b: the second of the two participants on the match
-   gls_a: the number of goals scored by ctry_a
-   gls_b: the number of goals scored by ctry_b

Do not display this data frame. Simply store it in `wc_grpstage` to use for the next task.

```{r c2}
wc_grpstage = wc_sched %>%
    mutate(
        gls = map2(ctry_a, ctry_b, ~ game_model(.x, .y)),
        gls_a = map_int(gls, 1),
        gls_b = map_int(gls, 2)
    ) %>%
    select(match, group, ctry_a, ctry_b, gls_a, gls_b)
```

#### C3. Group Stage Standings \[*6 pts*\]

After all the group stage matches have been played, create a table (using `gt`) such that the results of the group stage can be displayed. This table must contain the following columns:

-   Group: the group (A to L) to which the match participants belong
-   Country: the name of the country
-   w: matches won by the country
-   D: matches drawn by the country
-   L: matches lost by the country
-   GF: total goals for the country during group stage
-   GA: total goals allowed by the country during group stage
-   Pts: total points earned by the country (3 pts for each win, 1 pt for each draw)

The table must be arranged as follows:

-   Group the countries by Group (from A to L).
-   Within each Group, sort by Pts (hi to lo).
    -   If some countries in a group are tied in Pts, then sort the tied countries by goal differential (GF - GA) (hi to lo).
    -   If still tied in goal differential, then sort the tied countries by GF (hi to lo).
    -   If still tied in GF, then sort by the Pts earned in the matches played among the tied countries (hi to lo).

```{r c3}
wc_matches = wc_grpstage |>
    mutate(
        winner = case_when(
            gls_a > gls_b ~ ctry_a,
            gls_b > gls_a ~ ctry_b,
            TRUE ~ "Draw"
        )
    ) |>
    pivot_longer(cols = c(ctry_a, ctry_b), names_to = "role", values_to = "country") |>
    group_by(group, country) |>
    summarize(
        w = sum(winner == country),  
        l = sum((winner != "Draw") & (winner != country)), 
        d = sum(winner == "Draw"), 
        GF = sum(ifelse(role == "ctry_a", gls_a, gls_b)),
        GA = sum(ifelse(role == "ctry_a", gls_b, gls_a)),
        Pts = 3 * w + d 
    ) |>
    arrange(group, desc(Pts), desc(GF - GA), desc(GF))

wc_matches |> gt() |>
    tab_header(title = "Group Stage Standings") |>
    cols_label(
        country = "Country",
        w = "Wins",
        l = "Losses",
        d = "Draws",
        GF = "Goals For",
        GA = "Goals Allowed",
        Pts = "Points"
    )


```

#### C4. Summary \[*3 pts*\]

Write a concluding paragraph on your observations during the completion of this section. Contain all your words within the blockquote below by replacing the word 'Summary' with your text.

> In Part C, we simulated the group stage matches of the World Cup using the probabilistic model outlined in part C1. The results provided insights into how the offensive and defensive statistics can influence which country wins in a game. The game showed that countries with a good balance between offensive and defensive plays as well as higher statistics tended to fair better in their matches by either winning or tieing their games and vice versa.

------------------------------------------------------------------------

## D. Bonus - Knockout Stage Predicting \[*33 pts total*\]

With the results of your group stage matches, determine how the remainder of the World Cup will proceed.

This will require a four-step process:

1.  Determine which 32 teams qualify for the knockout stage. You will need to research the rules on this on your own. Go [here](https://en.wikipedia.org/wiki/2026_FIFA_World_Cup#Knockout_stage) or ask one of the instructors (esp Prof Yi) for guidance on this process.
2.  Revise the game model from the group stage to allow for extra time (30 minutes if tied at the end of 90 minutes) and penalty kick shootout (if still tied at the end of extra time). As opposed to the group stage matches, a winner must be determined for each match. Note that the probability of scoring on a penalty kick is 0.8.
3.  Play all the matches of the knockout stage (including the third-place playoff).
4.  Visualize the knockout stage results in a bracket-like format.

Use as many code chunks as you see fit. In general, four should be sufficient and aligned with the steps outlined above.

No summary for this section is necessary.

```{r d1}
top_two_countries = wc_matches %>%
    group_by(group) %>%
    slice_max(order_by = Pts, n = 2, with_ties = FALSE)

top_3rd_countries = wc_matches %>%
    group_by(group) %>%
    slice_max(order_by = Pts, n = 3, with_ties = FALSE) %>%
    slice_tail(n = 1) %>%
    ungroup() %>%
    arrange(desc(Pts), desc(GF - GA), desc(GF)) %>%
    slice_head(n = 8)

knockout_countries = bind_rows(top_two_countries, top_3rd_countries) %>%
    arrange(group, desc(Pts), desc(GF - GA), desc(GF)) %>%
    group_by(group) %>%
    mutate(rank = row_number(desc(Pts))) # Add a new column called rank

print(n = 32, knockout_countries)
```

```{r d2}
game_model = function(a, b) {
    stats_a = wc_countries %>%
        filter(country == a)
    stats_b = wc_countries %>%
        filter(country == b)
    
    total_time = 0
    goals_a = 0
    goals_b = 0
    possession = "a"

    while (total_time < 90 * 60) { # 90 minutes
        # bare min time of 5 seconds
        possession_time = max(5, round(rnorm(1, mean = 45, sd = 13))) 

        # Check if the first half ends
        if (total_time < 45 * 60 && total_time + possession_time > 45 * 60) {
            possession = "b" 
            total_time = 45 * 60
            next
        }

        total_time = total_time + possession_time 
        bias = sample(c("offensive", "defensive"), 1)

        # Scoring Mechanics
        if (possession == "a") {
            if (bias == "offensive") { # Offensive bias for ctry_a
                if (runif(1) < stats_a$osp && runif(1) < stats_a$ogs) {
                    goals_a = goals_a + 1
                }
            } else { # Defensive bias for ctry_b
                if (runif(1) < stats_b$dsp && runif(1) < stats_b$dgs) {
                    goals_b = goals_b + 1
                }
            }
            possession = "b"
        } else {
            if (bias == "offensive") { # Offensive bias for ctry_b
                if (runif(1) < stats_b$osp && runif(1) < stats_b$ogs) {
                    goals_b = goals_b + 1
                }
            } else { # Defensive bias for ctry_a
                if (runif(1) < stats_a$dsp && runif(1) < stats_a$dgs) {
                    goals_a = goals_a + 1
                }
            }
            possession = "a"
        }
    }
    
    # new code starts here: extra time
    if (goals_a == goals_b) {
      extra_time = 0
      while (extra_time < 30 *60) {
        # bare min time of 5 seconds
        possession_time = max(5, round(rnorm(1, mean = 45, sd = 13))) 
        
        #check if extra time ends
        if (extra_time < 30 * 60 && extra_time + possession_time > 30 * 60) {
          extra_time = 30 * 60
          next
        }
        
        extra_time = extra_time + possession_time
        bias = sample(c("offensive", "defensive"), 1)
        
        # Same scoring mechanics as before
        if (possession == "a") {
            if (bias == "offensive") { # Offensive bias for ctry_a
                if (runif(1) < stats_a$osp && runif(1) < stats_a$ogs) {
                    goals_a = goals_a + 1
                }
            } else { # Defensive bias for ctry_b
                if (runif(1) < stats_b$dsp && runif(1) < stats_b$dgs) {
                    goals_b = goals_b + 1
                }
            }
            possession = "b"
        } else {
            if (bias == "offensive") { # Offensive bias for ctry_b
                if (runif(1) < stats_b$osp && runif(1) < stats_b$ogs) {
                    goals_b = goals_b + 1
                }
            } else { # Defensive bias for ctry_a
                if (runif(1) < stats_a$dsp && runif(1) < stats_a$dgs) {
                    goals_a = goals_a + 1
                }
            }
            possession = "a"
        }
        
      }
      
      # penalty kick shootout - best of 5 means first to 3 points wins (whoever kicks first gets an advantage)
      if (goals_a == goals_b) {
        a_penalty_points = 0
        b_penalty_points = 0
        
        # team a wins coin flip, kicks first
        if (runif(1) < 0.5) {
          while (a_penalty_points < 3 && b_penalty_points < 3) {
            if (runif(1) < 0.8) {
              a_penalty_points = a_penalty_points + 1
            }
            if (a_penalty_points == 3) {
              break
            }
            if (runif(1) < 0.8) {
              b_penalty_points = b_penalty_points + 1
            }
            
          }
        #team b wins coin flip, kicks first
        } else {
          while (a_penalty_points < 3 && b_penalty_points < 3) {
            if (runif(1) < 0.8) {
              b_penalty_points = b_penalty_points + 1
            }
            if (b_penalty_points == 3) {
              break
            }
            if (runif(1) < 0.8) {
              a_penalty_points = a_penalty_points + 1
            }
          }
        }
        
        if (a_penalty_points > b_penalty_points) {
          goals_a = goals_a + 1
        } else {
          goals_b = goals_b + 1
        }
      }
    }
    return(c(goals_a, goals_b))
}

```

```{r d3}
round_of_32 = function(knockout_countries) {
    matchups = list(
        c("A2", "B2"), c("E1", "3"), c("F1", "C2"), c("C1", "F2"),
        c("I1", "3"), c("E2", "I2"), c("A1", "3"), c("L1", "3"),
        c("D1",  "3"), c("G1", "3"), c("K2", "L2"), c("H1", "J2"),
        c("B1", "3"), c("J1", "H2"), c("K1", "3"), c("D2", "G2")
    ) # matchups according to the wikipedia page
    winners = c()

    for (match in matchups) {
        team_a = knockout_countries$country[
            knockout_countries$group == substr(match[1], 1, 1) & # Get the group
            knockout_countries$rank == as.numeric(substr(match[1], 2, 2)) # Get the rank
            ] 
        if (match[2] == "3") {
            team_b = sample(knockout_countries$country[
                knockout_countries$rank == 3
            ], 1) # Randomly samples 1 3rd place team
        } else {
            team_b = knockout_countries$country[
                knockout_countries$group == substr(match[1], 1, 1) & # Get the group
                knockout_countries$rank == as.numeric(substr(match[1], 2, 2)) # Get the rank
            ]
        }
        result = game_model(team_a, team_b) 
        if (result[1] > result[2]) {
            winners = c(winners, team_a)
        } else {
            winners = c(winners, team_b)
        }
    }
    return(winners)
}

run_round = function(winners, matchups) {
    winners = c()
    for (match in matchups) {
        team_a = match[1]
        team_b = match[2]
        result = game_model(team_a, team_b)
        if (result[1] > result[2]) {
            winners = c(winners, team_a)
        } else {
            winners = c(winners, team_b)
        }
    }
    return(winners)
}


winners_32 = round_of_32(knockout_countries)
matchups_16 = list(
        c(winners_32[1], winners_32[2]), c(winners_32[3], winners_32[4]),
        c(winners_32[5], winners_32[6]), c(winners_32[7], winners_32[8]),
        c(winners_32[9], winners_32[10]), c(winners_32[11], winners_32[12]),
        c(winners_32[13], winners_32[14]), c(winners_32[15], winners_32[16])
    );

winners_16 = run_round(winners, matchups_16)
matchups_qf = list(
        c(winners_16[1], winners_16[2]), c(winners_16[3], winners_16[4]),
        c(winners_16[5], winners_16[6]), c(winners_16[7], winners_16[8])
    );

winners_qf = run_round(winners_16, matchups_qf)
matchups_sf = list(
        c(winners_qf[1], winners_qf[2]), c(winners_qf[3], winners_qf[4])
    );

winners_sf = run_round(winners_qf, matchups_sf)
matchups_f = list(
        c(winners_sf[1], winners_sf[2])
    );

winners = run_round(winners_sf, matchups_f)
winners

```

```{r d4}
# Prepare the data
data <- data.frame(
    Round = c(
        rep(0, nrow(knockout_countries)),
        rep(1, length(winners_32)),
        rep(2, length(winners_16)),
        rep(3, length(winners_qf)),
        rep(4, length(winners_sf)),
        5
    ),
    Winner = c(
        knockout_countries$country,
        winners_32,
        winners_16,
        winners_qf,
        winners_sf,
        winners)
    ) %>%
    group_by(Winner) %>%
    mutate(TeamID = cur_group_id())

# Visualize the data
hchart(
    data,
    "line",
    hcaes(x = Round, y = TeamID, group = Winner)
) %>%
    hc_title(text = "2026 WC Bracket Prediction") %>%
    hc_xAxis(title = list(text = "Round")) %>%
    hc_yAxis(title = list(text = "Teams")) %>%
    hc_tooltip(pointFormat = "Team: {point.Winner}") %>%
    hc_plotOptions(
        line = list(
            marker = list(
                enabled = TRUE,
                symbol = "circle"
            )
        ),
        series = list(showInLegend = FALSE)
    ) %>%
    hc_annotations(
        list(
            labels = list(
                list(
                    point = list(x = 5, y = data$TeamID[data$Round == 5]),
                    text = paste("World Cup Champion:", winners)
                )
            ) # Only find the data point at round 5
        )
    )




```

------------------------------------------------------------------------

## Z. Wrap Up

When you are ready to submit your project, follow these steps:

1.  Click the `Render` button to compile this document. An HTML file will be created in the folder containing this QMD file.

2.  While the HTML file is opened in a browser (e.g. Chrome, Safari), print it to a PDF file. Do not choose the 'Export as PDF' option on Safari. This will create one giant page in the PDF, making it impossible to grade. Your final PDF must be separated into individual letter-sized pages before submitting.

3.  Submit the PDF file to **Gradescope** (not to Canvas). Only one person per team needs to submit. Any confusion with multiple entries per team will result in point deductions in the final grade.
